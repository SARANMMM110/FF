import { readFileSync, writeFileSync, readdirSync } from 'fs';
import { join } from 'path';
import { fileURLToPath } from 'url';
import path from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const migrationsDir = path.join(__dirname, '../migrations');

console.log('üîÑ Generating MySQL schema file from migrations...');

// Get all migration files sorted by number
const migrationFiles = readdirSync(migrationsDir)
  .filter(file => file.endsWith('.sql') && !file.includes('down'))
  .map(file => {
    const match = file.match(/^(\d+)\.sql$/);
    if (match) {
      return {
        number: parseInt(match[1], 10),
        file: file,
        path: join(migrationsDir, file),
      };
    }
    return null;
  })
  .filter((m): m is { number: number; file: string; path: string } => m !== null)
  .sort((a, b) => a.number - b.number);

console.log(`üìã Found ${migrationFiles.length} migration files`);

// First pass: Extract all TEXT columns and UNIQUE TEXT columns from all tables across all migrations
const textColumns = new Map<string, Set<string>>(); // table -> set of TEXT column names
const uniqueTextColumns = new Map<string, Set<string>>(); // table -> set of UNIQUE TEXT column names

console.log('üîç Analyzing table schemas to identify TEXT columns...');
for (const migration of migrationFiles) {
  let sql = readFileSync(migration.path, 'utf-8');
  
  // Extract CREATE TABLE statements and identify TEXT columns
  const tableMatches = sql.matchAll(/CREATE TABLE\s+(\w+)\s*\(([^)]+)\)/gi);
  for (const match of tableMatches) {
    const tableName = match[1];
    const columnsDef = match[2];
    
    if (!textColumns.has(tableName)) {
      textColumns.set(tableName, new Set<string>());
    }
    const textCols = textColumns.get(tableName)!;
    
    // Parse column definitions - handle multi-line and single-line
    const columnLines = columnsDef.split(',').map((line: string) => line.trim());
    for (const line of columnLines) {
      // Match: column_name TEXT ... (with various modifiers)
      const colMatch = line.match(/^(\w+)\s+TEXT/i);
      if (colMatch) {
        textCols.add(colMatch[1]);
      }
      
      // Also track UNIQUE TEXT columns
      const uniqueMatch = line.match(/^(\w+)\s+TEXT.*UNIQUE/i);
      if (uniqueMatch) {
        if (!uniqueTextColumns.has(tableName)) {
          uniqueTextColumns.set(tableName, new Set<string>());
        }
        uniqueTextColumns.get(tableName)!.add(uniqueMatch[1]);
      }
    }
  }
}

let combinedSQL = `-- FocusFlow MySQL Database Schema
-- Generated from migrations
-- DO NOT EDIT THIS FILE - It is auto-generated
-- Run migrations using: npm run migrate

-- Create migrations tracking table
CREATE TABLE IF NOT EXISTS _migrations (
  id INT AUTO_INCREMENT PRIMARY KEY,
  migration_number INTEGER UNIQUE NOT NULL,
  applied_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

`;

// Second pass: Process each migration file
for (const migration of migrationFiles) {
  console.log(`üìÑ Processing migration ${migration.number}...`);
  
  let sql = readFileSync(migration.path, 'utf-8');
  
  // Convert SQLite syntax to MySQL
  // Remove UNIQUE from TEXT columns (MySQL requires key length, handle via UNIQUE INDEX instead)
  sql = sql.replace(/TEXT\s+NOT\s+NULL\s+UNIQUE/gi, 'TEXT NOT NULL');
  sql = sql.replace(/TEXT\s+UNIQUE/gi, 'TEXT');
  // Remove default values from TEXT columns (MySQL doesn't allow this)
  sql = sql.replace(/TEXT\s+NOT\s+NULL\s+DEFAULT\s+'[^']*'/gi, 'TEXT NOT NULL');
  sql = sql.replace(/TEXT\s+DEFAULT\s+'[^']*'/gi, 'TEXT');
  sql = sql.replace(/INTEGER PRIMARY KEY AUTOINCREMENT/g, 'INT AUTO_INCREMENT PRIMARY KEY');
  sql = sql.replace(/AUTOINCREMENT/g, 'AUTO_INCREMENT');
  sql = sql.replace(/DATETIME/g, 'TIMESTAMP');
  sql = sql.replace(/BOOLEAN DEFAULT 0/g, 'BOOLEAN DEFAULT FALSE');
  sql = sql.replace(/BOOLEAN DEFAULT 1/g, 'BOOLEAN DEFAULT TRUE');
  sql = sql.replace(/INTEGER PRIMARY KEY(?!\s+AUTO_INCREMENT)/g, 'INT PRIMARY KEY');
  // Convert SQLite INSERT syntax to MySQL
  sql = sql.replace(/INSERT\s+OR\s+IGNORE\s+INTO/gi, 'INSERT IGNORE INTO');
  sql = sql.replace(/INSERT\s+OR\s+REPLACE\s+INTO/gi, 'REPLACE INTO');
  
  // Escape reserved keywords in ALTER TABLE statements (e.g., 'repeat' is a MySQL reserved keyword)
  // Pattern: ALTER TABLE table ADD COLUMN column_name ... -> ALTER TABLE table ADD COLUMN `column_name` ...
  sql = sql.replace(/ALTER\s+TABLE\s+(\w+)\s+ADD\s+COLUMN\s+(\w+)(\s+.*?)(?=;|$)/gi, (match, tableName, columnName, rest) => {
    const reservedKeywords = new Set([
      'repeat', 'order', 'group', 'select', 'insert', 'update', 'delete', 'create', 'drop',
      'alter', 'table', 'index', 'key', 'primary', 'foreign', 'references', 'constraint',
      'default', 'null', 'not', 'unique', 'check', 'auto_increment', 'timestamp', 'datetime',
      'date', 'time', 'year', 'text', 'varchar', 'char', 'int', 'integer', 'bigint', 'smallint',
      'tinyint', 'decimal', 'float', 'double', 'real', 'boolean', 'bool', 'blob', 'binary',
      'varbinary', 'enum', 'set', 'json'
    ]);
    
    if (reservedKeywords.has(columnName.toLowerCase())) {
      return `ALTER TABLE ${tableName} ADD COLUMN \`${columnName}\`${rest}`;
    }
    return match;
  });
  
  // Add IF NOT EXISTS to CREATE TABLE statements
  sql = sql.replace(/CREATE TABLE (\w+)/g, 'CREATE TABLE IF NOT EXISTS $1');
  
  // MySQL: Add key length ONLY to TEXT columns in indexes (required by MySQL)
  sql = sql.replace(/CREATE INDEX (\w+) ON (\w+)\(([^)]+)\)/g, (match, indexName, tableName, columns) => {
    const textCols = textColumns.get(tableName) || new Set<string>();
    const uniqueTextCols = uniqueTextColumns.get(tableName) || new Set<string>();
    const cols = columns.split(',').map((col: string) => {
      const trimmed = col.trim();
      // Remove any existing length specification first
      const colName = trimmed.replace(/\([^)]*\)$/, '');
      
      // Only add key length if this is a TEXT column
      if (textCols.has(colName)) {
        return `${colName}(255)`;
      }
      return colName;
    });
    
    // Check if this index is on a single UNIQUE TEXT column - convert to UNIQUE INDEX
    const singleCol = cols.length === 1;
    const colName = singleCol ? cols[0].replace(/\([^)]*\)$/, '') : null;
    const isUniqueTextCol = colName && uniqueTextCols.has(colName);
    
    if (isUniqueTextCol && singleCol) {
      return `CREATE UNIQUE INDEX ${indexName} ON ${tableName}(${cols.join(', ')})`;
    }
    
    return `CREATE INDEX ${indexName} ON ${tableName}(${cols.join(', ')})`;
  });
  
  // For UNIQUE TEXT columns that don't have an index, add UNIQUE INDEX
  for (const [tableName, cols] of uniqueTextColumns.entries()) {
    for (const colName of cols) {
      // Check if there's already an index for this column
      const hasIndex = sql.match(new RegExp(`CREATE\\s+(?:UNIQUE\\s+)?INDEX\\s+\\w+\\s+ON\\s+${tableName}\\s*\\([^)]*${colName}`, 'i'));
      if (!hasIndex) {
        // Add UNIQUE INDEX after the CREATE TABLE statement
        sql = sql.replace(
          new RegExp(`(CREATE TABLE IF NOT EXISTS ${tableName}[^;]+;)`, 'i'),
          `$1\nCREATE UNIQUE INDEX idx_${tableName}_${colName}_unique ON ${tableName}(${colName}(255));`
        );
      }
    }
  }
  
  // Add migration comment
  combinedSQL += `\n-- Migration ${migration.number}\n`;
  combinedSQL += sql;
  combinedSQL += '\n';
}

// Write to file
const outputPath = path.join(__dirname, '../schema.mysql.sql');
writeFileSync(outputPath, combinedSQL, 'utf-8');

console.log(`‚úÖ MySQL schema file generated: ${outputPath}`);
console.log(`üì¶ You can now import this file to your MySQL database:`);
console.log(`   mysql -u frankimsocial_ff -p frankimsocial_ff < schema.mysql.sql`);

